From 19f672b4d186d8c99b5a653c0c62ca980f078032 Mon Sep 17 00:00:00 2001
From: Kyle Harrison <khwebmail@gmail.com>
Date: Tue, 19 Oct 2021 15:04:47 +0100
Subject: [PATCH 4/4] [WIP] Camera HAL1 fixes

Change-Id: I76fcc96b459f7c1c7605b5957646118aea6c2aa5
---
 camera/Camera.cpp                             |  4 +-
 .../aidl/android/hardware/ICameraService.aidl |  2 +-
 camera/include/camera/Camera.h                |  2 +-
 .../camera/libcameraservice/CameraService.cpp | 15 +++----
 .../camera/libcameraservice/CameraService.h   |  2 +-
 .../libcameraservice/api1/CameraClient.cpp    | 41 ++++++++++++++-----
 .../libcameraservice/api1/CameraClient.h      |  4 ++
 .../common/CameraProviderManager.cpp          |  4 ++
 .../common/CameraProviderManager.h            |  1 +
 9 files changed, 52 insertions(+), 23 deletions(-)

diff --git a/camera/Camera.cpp b/camera/Camera.cpp
index 2a0b90012a..f65725f129 100644
--- a/camera/Camera.cpp
+++ b/camera/Camera.cpp
@@ -80,7 +80,7 @@ sp<Camera> Camera::connect(int cameraId, const String16& clientPackageName,
 
 status_t Camera::connectLegacy(int cameraId, int halVersion,
         const String16& clientPackageName,
-        int clientUid,
+        int clientUid, int clientPid,
         sp<Camera>& camera)
 {
     ALOGV("%s: connect legacy camera device", __FUNCTION__);
@@ -92,7 +92,7 @@ status_t Camera::connectLegacy(int cameraId, int halVersion,
     binder::Status ret;
     if (cs != nullptr) {
         ret = cs.get()->connectLegacy(cl, cameraId, halVersion, clientPackageName,
-                clientUid, /*out*/&(c->mCamera));
+                clientUid, clientPid, /*out*/&(c->mCamera));
     }
     if (ret.isOk() && c->mCamera != nullptr) {
         IInterface::asBinder(c->mCamera)->linkToDeath(c);
diff --git a/camera/aidl/android/hardware/ICameraService.aidl b/camera/aidl/android/hardware/ICameraService.aidl
index 169e52aa57..0bfdb971e3 100644
--- a/camera/aidl/android/hardware/ICameraService.aidl
+++ b/camera/aidl/android/hardware/ICameraService.aidl
@@ -108,7 +108,7 @@ interface ICameraService
             int cameraId,
             int halVersion,
             String opPackageName,
-            int clientUid);
+            int clientUid, int clientPid);
 
     /**
      * Add listener for changes to camera device and flashlight state.
diff --git a/camera/include/camera/Camera.h b/camera/include/camera/Camera.h
index 296dc57781..c811c605a9 100644
--- a/camera/include/camera/Camera.h
+++ b/camera/include/camera/Camera.h
@@ -86,7 +86,7 @@ public:
 
     static  status_t  connectLegacy(int cameraId, int halVersion,
                                      const String16& clientPackageName,
-                                     int clientUid, sp<Camera>& camera);
+                                     int clientUid, int clientPid, sp<Camera>& camera);
 
             virtual     ~Camera();
 
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index e1359f123a..b6f8ab2647 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -876,7 +876,7 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
         const sp<IInterface>& cameraCb, const String16& packageName,
         const std::optional<String16>& featureId,  const String8& cameraId,
         int api1CameraId, int facing, int sensorOrientation, int clientPid, uid_t clientUid,
-        int servicePid, int deviceVersion, apiLevel effectiveApiLevel, int halVersion, bool overrideForPerfClass,
+        int servicePid, int halVersion, int deviceVersion, apiLevel effectiveApiLevel, bool overrideForPerfClass,
         /*out*/sp<BasicClient>* client) {
 
     if (halVersion < 0 || halVersion == deviceVersion) {
@@ -887,7 +887,7 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
             if (effectiveApiLevel == API_1) {  // Camera1 API route
                 sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
                 *client = new CameraClient(cameraService, tmp, packageName, featureId,
-                        api1CameraId, facing, clientPid, clientUid,
+                        api1CameraId, facing, sensorOrientation, clientPid, clientUid,
                         getpid());
             } else { // Camera2 API route
                 ALOGW("Camera using old HAL version: %d", deviceVersion);
@@ -933,7 +933,7 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
             // Only support higher HAL version device opened as HAL1.0 device.
             sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
             *client = new CameraClient(cameraService, tmp, packageName, featureId,
-                    api1CameraId, facing, clientPid, clientUid,
+                    api1CameraId, facing, sensorOrientation, clientPid, clientUid,
                     servicePid);
         } else {
             // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.
@@ -1560,7 +1560,7 @@ Status CameraService::connect(
     sp<Client> client = nullptr;
     ret = connectHelper<ICameraClient,Client>(cameraClient, id, api1CameraId,
             CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, {},
-            clientUid, clientPid, API_1, /*shimUpdateOnly*/ false, /*out*/client);
+            clientUid, clientPid, API_1, /*shimUpdateOnly*/ false, /*scoreOffset*/ 0, targetSdkVersion, /*out*/client);
 
     if(!ret.isOk()) {
         logRejected(id, CameraThreadState::getCallingPid(), String8(clientPackageName),
@@ -1576,7 +1576,7 @@ Status CameraService::connectLegacy(
         const sp<ICameraClient>& cameraClient,
         int api1CameraId, int halVersion,
         const String16& clientPackageName,
-        int clientUid,
+        int clientUid, int clientPid,
         /*out*/
         sp<ICamera>* device) {
 
@@ -1587,7 +1587,8 @@ Status CameraService::connectLegacy(
     sp<Client> client = nullptr;
     ret = connectHelper<ICameraClient,Client>(cameraClient, id, api1CameraId, halVersion,
             clientPackageName, {}, clientUid, clientPid, API_1,
-            /*shimUpdateOnly*/ false, /*out*/client);
+            /*shimUpdateOnly*/ false, /*scoreOffset*/0,
+            __ANDROID_API_FUTURE__, /*out*/client);
 
     if(!ret.isOk()) {
         logRejected(id, CameraThreadState::getCallingPid(), String8(clientPackageName),
@@ -1702,7 +1703,7 @@ Status CameraService::connectDevice(
     ret = connectHelper<hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient>(cameraCb, id,
             /*api1CameraId*/-1,
             CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageNameAdj, clientFeatureId,
-            clientUid, USE_CALLING_PID, API_2, /*shimUpdateOnly*/ false, /*out*/client);
+            clientUid, USE_CALLING_PID, API_2, /*shimUpdateOnly*/ false, /*scoreOffset*/0,
             targetSdkVersion, /*out*/client);
 
     if(!ret.isOk()) {
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index e79fff25a9..0b2deb8890 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -138,7 +138,7 @@ public:
 
     virtual binder::Status     connectLegacy(const sp<hardware::ICameraClient>& cameraClient,
             int32_t cameraId, int32_t halVersion,
-            const String16& clientPackageName, int32_t clientUid,
+            const String16& clientPackageName, int32_t clientUidclientPid, int clientPid,
             /*out*/
             sp<hardware::ICamera>* device);
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index b860ceb7fc..1d08b2a6e1 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -26,6 +26,7 @@
 #include "device1/CameraHardwareInterface.h"
 #include "CameraService.h"
 #include "utils/CameraThreadState.h"
+#include "utils/CameraServiceProxyWrapper.h"
 
 namespace android {
 
@@ -35,11 +36,11 @@ namespace android {
 CameraClient::CameraClient(const sp<CameraService>& cameraService,
         const sp<hardware::ICameraClient>& cameraClient,
         const String16& clientPackageName, const std::optional<String16>& clientFeatureId,
-        int cameraId, int cameraFacing,
+        int cameraId, int cameraFacing, int sensorOrientation,
         int clientPid, int clientUid,
         int servicePid):
         Client(cameraService, cameraClient, clientPackageName, clientFeatureId,
-                String8::format("%d", cameraId), cameraId, cameraFacing, clientPid,
+                String8::format("%d", cameraId), cameraId, cameraFacing, sensorOrientation, clientPid,
                 clientUid, servicePid)
 {
     int callingPid = CameraThreadState::getCallingPid();
@@ -237,6 +238,7 @@ static void disconnectWindow(const sp<ANativeWindow>& window) {
 }
 
 binder::Status CameraClient::disconnect() {
+    nsecs_t startTime = systemTime();
     int callingPid = CameraThreadState::getCallingPid();
     LOG1("disconnect E (pid %d)", callingPid);
     Mutex::Autolock lock(mLock);
@@ -258,10 +260,12 @@ binder::Status CameraClient::disconnect() {
     // Turn off all messages.
     disableMsgType(CAMERA_MSG_ALL_MSGS);
     mHardware->stopPreview();
+    /*
     sCameraService->updateProxyDeviceState(
-            hardware::ICameraServiceProxy::CAMERA_STATE_IDLE,
+            hardware::CameraSessionStats::CAMERA_STATE_IDLE,
             mCameraIdStr, mCameraFacing, mClientPackageName,
-            hardware::ICameraServiceProxy::CAMERA_API_LEVEL_1);
+            hardware::CameraSessionStats::CAMERA_API_LEVEL_1);
+    */
     mHardware->cancelPicture();
     // Release the hardware resources.
     mHardware->release();
@@ -277,7 +281,8 @@ binder::Status CameraClient::disconnect() {
     CameraService::Client::disconnect();
 
     LOG1("disconnect X (pid %d)", callingPid);
-
+    int32_t closeLatencyMs = ns2ms(systemTime() - startTime);
+    CameraServiceProxyWrapper::logClose(mCameraIdStr, closeLatencyMs);
     return res;
 }
 
@@ -421,10 +426,12 @@ status_t CameraClient::startPreviewMode() {
     mHardware->setPreviewWindow(mPreviewWindow);
     result = mHardware->startPreview();
     if (result == NO_ERROR) {
+/*
         sCameraService->updateProxyDeviceState(
-            hardware::ICameraServiceProxy::CAMERA_STATE_ACTIVE,
+            hardware::CameraSessionStats::CAMERA_STATE_ACTIVE,
             mCameraIdStr, mCameraFacing, mClientPackageName,
-            hardware::ICameraServiceProxy::CAMERA_API_LEVEL_1);
+            hardware::CameraSessionStats::CAMERA_API_LEVEL_1);
+*/
     }
     return result;
 }
@@ -465,10 +472,12 @@ void CameraClient::stopPreview() {
 
     disableMsgType(CAMERA_MSG_PREVIEW_FRAME);
     mHardware->stopPreview();
+    /*
     sCameraService->updateProxyDeviceState(
-        hardware::ICameraServiceProxy::CAMERA_STATE_IDLE,
+        hardware::CameraSessionStats::CAMERA_STATE_IDLE,
         mCameraIdStr, mCameraFacing, mClientPackageName,
-        hardware::ICameraServiceProxy::CAMERA_API_LEVEL_1);
+        hardware::CameraSessionStats::CAMERA_API_LEVEL_1);
+    */
     mPreviewBuffer.clear();
 }
 
@@ -958,10 +967,12 @@ void CameraClient::handleShutter(void) {
 
     // Shutters only happen in response to takePicture, so mark device as
     // idle now, until preview is restarted
+    /*
     sCameraService->updateProxyDeviceState(
-        hardware::ICameraServiceProxy::CAMERA_STATE_IDLE,
+        hardware::CameraSessionStats::CAMERA_STATE_IDLE,
         mCameraIdStr, mCameraFacing, mClientPackageName,
-        hardware::ICameraServiceProxy::CAMERA_API_LEVEL_1);
+        hardware::CameraSessionStats::CAMERA_API_LEVEL_1);
+    */
 
     mLock.unlock();
 }
@@ -1205,4 +1216,12 @@ status_t CameraClient::setRotateAndCropOverride(uint8_t /*rotateAndCrop*/) {
     return OK;
 }
 
+bool CameraClient::supportsCameraMute() {
+    return false;
+}
+
+status_t CameraClient::setCameraMute(bool /*enabled*/) {
+    return OK;
+}
+
 }; // namespace android
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index aacb00ee9a..20e320a00b 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -64,6 +64,9 @@ public:
 
     virtual status_t        setRotateAndCropOverride(uint8_t override);
 
+    virtual bool            supportsCameraMute();
+    virtual status_t        setCameraMute(bool enabled);
+
     // Interface used by CameraService
     CameraClient(const sp<CameraService>& cameraService,
             const sp<hardware::ICameraClient>& cameraClient,
@@ -71,6 +74,7 @@ public:
             const std::optional<String16>& clientFeatureId,
             int cameraId,
             int cameraFacing,
+            int sensorOrientation,
             int clientPid,
             int clientUid,
             int servicePid);
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.cpp b/services/camera/libcameraservice/common/CameraProviderManager.cpp
index 4089c909ef..78fd046490 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.cpp
+++ b/services/camera/libcameraservice/common/CameraProviderManager.cpp
@@ -2374,6 +2374,10 @@ status_t CameraProviderManager::ProviderInfo::DeviceInfo1::setTorchMode(bool ena
     return setTorchModeForDevice<InterfaceT>(enabled);
 }
 
+status_t CameraProviderManager::ProviderInfo::DeviceInfo1::filterSmallJpegSizes() {
+    return OK;
+}
+
 status_t CameraProviderManager::ProviderInfo::DeviceInfo1::getCameraInfo(
         hardware::CameraInfo *info) const {
     if (info == nullptr) return BAD_VALUE;
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.h b/services/camera/libcameraservice/common/CameraProviderManager.h
index c1d5c164ea..c7a62fb158 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.h
+++ b/services/camera/libcameraservice/common/CameraProviderManager.h
@@ -545,6 +545,7 @@ private:
             typedef hardware::camera::device::V1_0::ICameraDevice InterfaceT;
 
             virtual status_t setTorchMode(bool enabled) override;
+            virtual status_t filterSmallJpegSizes() override;
             virtual status_t getCameraInfo(hardware::CameraInfo *info) const override;
             //In case of Device1Info assume that we are always API1 compatible
             virtual bool isAPI1Compatible() const override { return true; }
-- 
2.33.0

